[
    {
        "query": "If a student is in obvious violations of copyright law by using a room's wired connection (ie ResNet) to distribute copyrighted materials, the room's connection will be disabled, and the issue could be sent to Housing Student Judicial Affairs",
        "answer": "Reasoning: \n1. Identify the network configuration action implied by the statement: to monitor students for violations of copyright law. \n2. Determine the important Nile entities: 'student' and implicitly, a copyright monitor. \n3. 'student' is not a value of any Nile entity, but according to Rule 7, 'students' is a value of type \"group\", which closest matches the value 'student'. We pair them together in Nile: group('students'). 'copyright monitor' is not a value of any Nile entity, but according to Rule 5, 'copyright monitoring' is a value of type \"middlebox\", which closest matches the value 'copyright monitor'.  We pair them together in Nile: middlebox('copyright monitoring'). \n4. Each Nile entity corresponds to one of the Nile operations in Rule 3. Since we want to add the middlebox, it corresponds to the Nile operation \"add\". A group always corresponds to the Nile operation \"for\". \n5. We put the Nile expressions together and add the header. \n\nNile translation: \ndefine intent uniIntent: \n\tfor group('students') \n\tadd middlebox('copyright monitoring')"
    }, 
    {
        "query": "CounterStrike server is blocked by the University firewall",
        "answer": "Reasoning: \n1. Identify the network configuration action implied by the statement: to add a firewall for the university that blocks the CounterStrike server. \n2. Determine the important Nile entities: 'CounterStrike', 'University', and 'firewall'. \n3. According to Rule 10, 'CounterStrike' is a value of the entity 'service', so we pair them together in Nile: service('CounterStrike'). 'University' is not a value of any Nile entity, but according to Rule 6, 'university' is a value of type \"endpoint\", which closest matches the value 'University'. We pair them together in Nile: endpoint('university'). 'firewall' is a value of the entity \"middlebox\", so we pair them together in Nile: middlebox(\"firewall\"). \n4. Each Nile entity corresponds to one of the Nile operations in Rule 3. Since we want to add the middlebox, it corresponds to the Nile operation \"add\". Since we want to block the service, it corresponds to the Nile operation \"block\". Since the endpoint is not an origin or a destination, it corresponds to the Nile operation \"for\". \n5. We put the Nile expressions together and add the header. \n\nNile translation: \ndefine intent uniIntent: \n\tfor endpoint('university') \n\tadd middlebox('firewall') \n\tblock service('CounterStrike server')"
    },
    {
        "query": "Currently, the University of Illinois does not have any rate limits set in place",
        "answer": "Reasoning: \n1. Identify the network configuration action implied by the statement: to not set rate limits for the University of Illinois. \n2. Determine the important Nile entities: 'University of Illinois' (an endpoint) and 'rate limits' (a bandwidth). \n3. 'University' is not a value of any Nile entity, but according to Rule 6, 'university' is a value of type \"endpoint\", which closest matches the value 'University'. 'rate limits' is a \"bandwidth\". According to Rule 13, a \"bandwidth\" can have either zero parameters or three parameters, in which case they must consist of a \"qos_constraint\" ('max' or 'min'), a \"qos_value\" (a number), and a \"qos_unit\". Since there is no \"qos_constraint\", \"qos_value\", and \"qos_unit\" specified, we give our \"bandwidth\" zero parameters. In Nile, we have: bandwidth(). \n4. Each Nile entity corresponds to one of the Nile operations in Rule 3. Since the endpoint is not an origin or a destination, it corresponds to the Nile operation \"for\". Since we do not want to set rate limits, the bandwidth corresponds to the Nile operation \"unset\". \n5. We put the Nile expressions together and add the header. \n\nNile translation: \ndefine intent uniIntent: \n\tfor endpoint('university') \n\tunset bandwidth()"
    },
    {
        "query": "Students 10 GB a day download quotas are on 10 AM to Midnight",
        "answer": "Reasoning: \n1. Identify the network configuration action implied by the statement: to set a download quota of 10 GB a day for students within the time frame of 10 AM to Midnight. \n2. Determine the important Nile entities: 'Students' (a group), a download quota of 10 GB a day (a quota), '10 AM' (an hour), and 'Midnight' (an hour). \n3. 'Students' is not a value of any Nile entity, but according to Rule 7, 'students' is a value of type \"group\", which closest matches the value 'Students'. We pair them together in Nile: group('students'). A quota is defined by three parameters, a \"qos_constraint\", a \"qos_value\", and a \"qos_unit\". The \"qos_constraint\" here is \"download\", the \"qos_value\" here is \"10\", and the \"qos_unit\" is \"gb/day\". We put them together in Nile: quota('download', '10', 'gb/day'). '10 AM' is an \"hour\", so we standardize the time and write it in Nile: hour('10:00'). 'Midnight' is an \"hour\", so we standardize the time and write it in Nile: hour('24:00'). \n4. Each Nile entity corresponds to one of the Nile operations in Rule 3. A quota is paired only with the operations \"set\" or \"unset\". Since we want to set the quota, it corresponds to the Nile operation \"set\". A group always corresponds to the Nile operation \"for\". Since '10:00' is a start time and '24:00' is an end time, they correspond to \"start\" and \"end\", respectively. \n5. We put the Nile expressions together and add the header. \n\nNile translation: \ndefine intent uniIntent: \n\tfor group('students') \n\tset quota('download', '10', 'gb/day') \n\tstart hour('10:00') \n\tend hour('24:00')"
    },
    {
        "query": "RHIT-OPEN will work in labs, classrooms and residence halls but does not allow the user to access the internal Rose-Hulman network",
        "answer": "Reasoning: \n1. Identify the network configuration action implied by the statement: to block all user traffic from RHIT-OPEN to the internal Rose-Hulman network. \n2. Determine the important Nile entities: 'RHIT-OPEN', the 'user', the traffic, and the 'internal Rose-Hulman network'. \n3. 'RHIT-OPEN' is not a value of any Nile entity. However, we observe that 'RHIT-OPEN' refers to a guest network. According to Rule 6, 'guests' is a value of type \"endpoint\", which closest matches the value 'RHIT-OPEN'. We pair them together in Nile: endpoint('guests'). 'user' is not a value of any Nile entity, but according to Rule 7, 'host' is a value of type \"group\", which closest matches the value 'user'. We pair them together in Nile: group('host'). The value of the \"traffic\" entity is not explicitly stated in the statement, so it is assumed to be all traffic, and we use the value 'any' as specified in Rule 8. We pair them together in Nile: traffic('any'). The 'internal Rose-Hulman network' is not a value of any Nile entity. However, we observe that the 'internal Rose-Hulman network' refers to the internal servers. According to Rule 6, 'servers' is a value of type \"endpoint\", which closest matches the value 'internal Rose-Hulman network'. We pair them together in Nile: endpoint('servers'). \n4. Each Nile entity corresponds to one of the Nile operations in Rule 3. Since the endpoint 'guests' is an origin, it corresponds to the Nile operation \"from\". Since the endpoint 'servers' is a destination, it corresponds to the Nile operation \"to\". A group always corresponds to the Nile operation \"for\". Since we want to block the traffic, it corresponds to the Nile operation \"block\". \n5. We put the Nile expressions together and add the header. \n\nNile translation: \ndefine intent uniIntent: \n\tfrom endpoint('guests') \n\tto endpoint('servers') \n\tfor group('host') \n\tblock traffic('any')"
    },
    {
        "query": "IMAP and secure IMAP are allowed by the University firewall",
        "answer": "Reasoning: \n1. Identify the network configuration action implied by the statement: to add a firewall for the university that allows IMAP and secure IMAP. \n2. Determine the important Nile entities: 'IMAP', 'secure IMAP', 'University', and 'firewall'. \n3. 'IMAP' is a value of the entity \"protocol\", so we pair them together in Nile: protocol('IMAP'). 'secure IMAP' is a value of the entity \"protocol\", so we pair them together in Nile: protocol('secure IMAP'). 'University' is not a value of any Nile entity, but according to Rule 6, 'university' is a value of type \"endpoint\", which closest matches the value 'University'. We pair them together in Nile: endpoint('university'). 'firewall' is a value of the entity \"middlebox\", so we pair them together in Nile: middlebox(\"firewall\"). \n4. Each Nile entity corresponds to one of the Nile operations in Rule 3. Since we want to add the middlebox, it corresponds to the Nile operation \"add\". Since we want to allow both the protocol \"IMAP\" and the protocol \"secure IMAP\", they both correspond to the Nile operation \"allow\". Since the endpoint is neither an origin nor a destination, it corresponds to the Nile operation \"for\". \n5. We put the Nile expressions together and add the header. \n\nNile translation: \ndefine intent uniIntent: \n\tfor endpoint('university') \n\tadd middlebox('firewall') \n\tallow protocol('IMAP'), protocol('secure IMAP')"
    },
    {
        "query": "When a total of 18 gigabytes of data is reached, the individual's bandwidth rate limit is set to 2 Mbps",
        "answer": "Reasoning: \n1. Identify the network configuration action implied by the statement: to set a bandwidth rate limit of 2 Mbps for the individual when a data quota of 18 gigabytes is reached. \n2. Determine the important Nile entities: a bandwidth rate limit of 2 Mbps, the 'individual', and a quota of 18 gigabytes of data. \n3. A bandwidth is defined by either zero or three parameters, in which case they are a \"qos_constraint\", a \"qos_value\", and a \"qos_unit\". The \"qos_constraint\" here is \"max\" because we want to cap the bandwidth, the \"qos_value\" here is \"2\", and the \"qos_unit\" is \"mbps\". We put them together in Nile: bandwidth('max', '2', 'mbps'). 'individual' is not a value of any Nile entity, but according to Rule 7, 'host' is a value of type \"group\", which closest matches the value 'individual'. We pair them together in Nile: group('host'). A quota is defined by three parameters, a \"qos_constraint\", a \"qos_value\", and a \"qos_unit\". The \"qos_constraint\" is not specified as either 'download' or 'upload', so we imply that it has the value 'download'. The \"qos_value\" here is '2', and the \"qos_unit\" is 'mbps'. We put them together in Nile: quota('download', '18', 'gb'). \n4. Each Nile entity corresponds to one of the Nile operations in Rule 3. A bandwidth is paired only with the operations \"set\" or \"unset\". Since we want to set the quota, it corresponds to the Nile operation \"set\". Since the endpoint is not an origin or a destination, it corresponds to the Nile operation \"for\". A quota is paired only with the operations \"set\" or \"unset\". Since we want to set the quota, it corresponds to the Nile operation \"set\". \n5. We put the Nile expressions together and add the header. \n\nNile translation: \ndefine intent uniIntent: \n\tfor endpoint('host') \n\tset quota('download', '18', 'gb'), bandwidth('max', '2', 'mbps')"
    }
]
