{
    "BgpProcessPropertySpec": {
        "description": "A specification for a set of BGP process properties (e.g., those returned by the bgpProcessConfiguration question).",
        "type": "enum",
        "values": [
            "Multipath_Match_Mode",
            "Multipath_EBGP",
            "Multipath_IBGP",
            "Neighbors",
            "Route_Reflector",
            "Tie_Breaker"
        ]
    },
    "BgpPeerPropertySpec": {
        "description": "A specification for a set of BGP peer properties (e.g., those returned by the bgpPeerConfiguration question).",
        "type": "enum",
        "values": [
            "Local_AS",
            "Local_IP",
            "Is_Passive",
            "Remote_AS",
            "Route_Reflector_Client",
            "Cluster_ID",
            "Peer_Group",
            "Import_Policy",
            "Export_Policy",
            "Send_Community"
        ]
    },
    "InterfacePropertySpec": {
        "description": "A specification for a set of interface-level properties (e.g., those returned by the interfaceProperties question).",
        "type": "enum",
        "values": [
            "Access_VLAN",
            "Active",
            "Allowed_VLANs",
            "All_Prefixes",
            "Auto_State_VLAN",
            "Bandwidth",
            "Blacklisted",
            "Channel_Group",
            "Channel_Group_Members",
            "Declared_Names",
            "Description",
            "DHCP_Relay_Addresses",
            "Encapsulation_VLAN",
            "HSRP_Groups",
            "HSRP_Version",
            "Incoming_Filter_Name",
            "MLAG_ID",
            "MTU",
            "Native_VLAN",
            "Outgoing_Filter_Name",
            "PBR_Policy_Name",
            "Primary_Address",
            "Primary_Network",
            "Proxy_ARP",
            "Rip_Enabled",
            "Rip_Passive",
            "Spanning_Tree_Portfast",
            "Speed",
            "Switchport",
            "Switchport_Mode",
            "Switchport_Trunk_Encapsulation",
            "VRF",
            "VRRP_Groups",
            "Zone_Name"
        ]
    },
    "InterfaceSpec": {
        "description": "A specification for interfaces in the network.",
        "examples": {
            "singleInterface": "Ethernet0/1",
            "regexInterface": "/^Eth/",
            "nodeSpecificInterface": "as1border1[Ethernet0/1]",
            "connectedToIP": "@connectedTo(ipSpec)",
            "interfaceGroup": "@interfaceGroup(book, group)",
            "vrfInterface": "@vrf(vrf1)",
            "zoneInterface": "@zone(zone3)"
        },
        "grammar": {
            "interfaceSpec": "interfaceTerm [(&|,|) interfaceTerm]",
            "interfaceTerm": [
                "interfaceWithNode",
                "interfaceWithoutNode",
                "(interfaceSpec)"
            ],
            "interfaceWithNode": "nodeTerm[interfaceWithoutNode]",
            "interfaceWithoutNode": "interfaceWithoutNodeTerm [(&|,|) interfaceWithoutNodeTerm]",
            "interfaceWithoutNodeTerm": [
                "<interface-name>",
                "/<interface-name-regex>/",
                "interfaceFunc",
                "(interfaceWithoutNode)"
            ],
            "interfaceFunc": [
                "@connectedTo(ipSpec)",
                "@interfaceGroup(<reference-book-name>, <<interface-group-name>)",
                "@vrf(<vrf-name>)",
                "@zone(<zone-name>)"
            ]
        }
    },
    "NodePropertySpec": {
        "description": "A specification for a set of node-level properties (e.g., those returned by the nodeProperties question).",
        "type": "enum",
        "values": [
            "AS_Path_Access_Lists",
            "Authentication_Key_Chains",
            "Canonical_IP",
            "Community_Match_Exprs",
            "Community_Set_Exprs",
            "Community_Set_Match_Exprs",
            "Community_Sets",
            "Configuration_Format",
            "Default_Cross_Zone_Action",
            "Default_Inbound_Action",
            "DNS_Servers",
            "DNS_Source_Interface",
            "Domain_Name",
            "Hostname",
            "IKE_Phase1_Keys",
            "IKE_Phase1_Policies",
            "IKE_Phase1_Proposals",
            "Interfaces",
            "IP_Access_Lists",
            "IP_Spaces",
            "IP6_Access_Lists",
            "IPsec_Peer_Configs",
            "IPsec_Phase2_Policies",
            "IPsec_Phase2_Proposals",
            "IPSec_Vpns",
            "Logging_Servers",
            "Logging_Source_Interface",
            "NTP_Servers",
            "NTP_Source_Interface",
            "PBR_Policies",
            "Route_Filter_Lists",
            "Route6_Filter_Lists",
            "Routing_Policies",
            "SNMP_Source_Interface",
            "SNMP_Trap_Servers",
            "TACACS_Servers",
            "TACACS_Source_Interface",
            "VRFs",
            "Zones"
        ]
    },
    "NodeSpec": {
        "description": "A specification for nodes in the network.",
        "examples": {
            "singleNode": "as1border1",
            "regexNode": "/^as1/",
            "roleNode": "@role(dim, role)"
        },
        "grammar": {
            "nodeSpec": "nodeTerm [(&|,|) nodeTerm]",
            "nodeTerm": [
                "<node-name>",
                "/<node-name-regex>/",
                "nodeFunc",
                "(nodeSpec)"
            ],
            "nodeFunc": "@role(<dimension-name>, <role-name>)"
        }
    },
    "IPProtocolSpecifier": {
        "description": "A specification for a set of IP protocols.",
        "examples": [
            "IP protocol names from the list below, such as TCP, may be used.",
            "IP protocol numbers between 0 and 255 (inclusive), such as 6 to denote TCP, may be used.",
            "A negation operator ! may be used to denote all IP protocols other than the one specified. The semantics of negation is:",
            "!TCP refers to all IP protocols other than TCP",
            "!TCP, !UDP refers to all IP protocols other than TCP and UDP",
            "TCP, !UDP refers to TCP"
        ],
        "grammar": {
            "ipProtocolSpec": [
                "ipProtocolTerm [, ipProtocolTerm]"
            ],
            "ipProtocolTerm": [
                "ipProtocol",
                "!ipProtocol"
            ],
            "ipProtocol": [
                "<ip-protocol-name>",
                "<ip-protocol-number>"
            ]
        },
        "names": [
            "AHP (51)",
            "AN (107)",
            "ANY_0_HOP_PROTOCOL (114)",
            "ANY_DISTRIBUTED_FILE_SYSTEM (68)",
            "ANY_HOST_INTERNAL_PROTOCOL (61)",
            "ANY_LOCAL_NETWORK (63)",
            "ANY_PRIVATE_ENCRYPTION_SCHEME (99)",
            "ARGUS (13)",
            "ARIS (104)",
            "AX25 (93)",
            "BBN_RCC_MON (10)",
            "BNA (49)",
            "BR_SAT_MON (76)",
            "CBT (7)",
            "CFTP (62)",
            "CHAOS (16)",
            "COMPAQ_PEER (110)",
            "CPHB (73)",
            "CPNX (72)",
            "CRTP (126)",
            "CRUDP (127)",
            "DCCP (33)",
            "DCN_MEAS (19)",
            "DDP (37)",
            "DDX (116)",
            "DGP (86)",
            "EGP (8)",
            "EIGRP (88)",
            "EMCON (14)",
            "ENCAP (98)",
            "ESP (50)",
            "ETHERIP (97)",
            "FC (133)",
            "FIRE (125)",
            "GGP (3)",
            "GMTP (100)",
            "GRE (47)",
            "HIP (139)",
            "HMP (20)",
            "HOPOPT (0)",
            "I_NLSP (52)",
            "IATP (117)",
            "IPV6_ROUTE (43)",
            "IPX_IN_IP (111)",
            "IRTP (28)",
            "ISIS (124)",
            "ISO_IP (80)",
            "ISO_TP4 (29)",
            "KRYPTOLAN (65)",
            "L2TP (115)",
            "LARP (91)",
            "LEAF1 (25)",
            "LEAF2 (26)",
            "MANAET (138)",
            "MERIT_INP (32)",
            "MFE_NSP (31)",
            "MHRP (48)",
            "MICP (95)",
            "MOBILE (55)",
            "MOBILITY (135)",
            "MPLS_IN_IP (137)",
            "MTP (92)",
            "MUX (18)",
            "NARP (54)",
            "NETBLT (30)",
            "NSFNET_IGP (85)",
            "NVPII (11)",
            "OSPF (89)",
            "PGM (113)",
            "PIM (103)",
            "PIPE (131)",
            "PNNI (102)",
            "PRM (21)",
            "PTP (123)",
            "PUP (12)",
            "PVP (75)",
            "QNX (106)",
            "RDP (27)",
            "ROHC (142)",
            "RSVP (46)",
            "RSVP_E2E_IGNORE (134)",
            "RVD (66)",
            "SAT_EXPAK (64)",
            "SAT_MON (69)",
            "SCC_SP (96)",
            "SCPS (105)",
            "SCTP (132)",
            "SDRP (42)",
            "SECURE_VMTP (82)",
            "SHIM6 (140)",
            "SKIP (57)",
            "SM (122)",
            "SMP (121)",
            "SNP (109)",
            "SPRITE_RPC (90)",
            "SPS (130)",
            "SRP (119)",
            "SSCOPMCE (128)",
            "ST (5)",
            "STP (118)",
            "SUN_ND (77)",
            "SWIPE (53)",
            "TCF (87)",
            "TCP (6)",
            "THREE_PC (34)",
            "TLSP (56)",
            "TPPLUSPLUS (39)",
            "TRUNK1 (23)",
            "TRUNK2 (24)",
            "TTP (84)",
            "UDP (17)",
            "UDP_LITE (136)",
            "UTI (120)",
            "VINES (83)",
            "VISA (70)",
            "VMTP (81)",
            "VRRP (112)",
            "WB_EXPAK (79)",
            "WB_MON (78)",
            "WESP (141)",
            "WSN (74)",
            "XNET (15)",
            "XNS_IDP (22)",
            "XTP (36)"
        ]
    },
    "IpSpec": {
        "description": "A specification for a set of IPv4 addresses.",
        "examples": [
            "Constant values that denote addresses (e.g., 1.2.3.4), prefixes (e.g., 1.2.3.0/24), address ranges (e.g., 1.2.3.4 - 1.2.3.7), and wildcards (e.g., 1.2.3.4:255.255.255.0) may be used.",
            "@addressGroup(book, group) looks in the configured reference library for an address group name 'group' in book name 'book'.",
            "locationSpec can be used to denote addresses corresponding to the specified location (see locationSpec). For example, as1border1[Ethernet0/0] includes all IPv4 addresses configured on as1border1 interface Ethernet0/0."
        ],
        "grammar": {
            "ipSpec": [
                "ipTerm[(&|,|) ipTerm]"
            ],
            "ipTerm": [
                "<ip-address>",
                "<ip-prefix>",
                "<ip-address-low> - <ip-address-high>",
                "<ip wildcard>",
                "@addressGroup(<reference-book-name>, <address-group-name>)",
                "locationSpec"
            ]
        }
    },
    "FilterSpec": {
        "description": "A specification for filters (ACLs or firewall rules) in the network.",
        "examples": {
            "filter1": "filter1 includes filters on all nodes with that name.",
            "regexFilter": "/^acl/ includes all filters (on all nodes) whose names match regex '^acl', i.e., begin with 'acl'.",
            "nodeSpecificFilter": "as1border1[filter1] indicates the filter 'filter1' on as1border1.",
            "incomingFilter": "@in(Ethernet0/0) refers to filters that get applied when packets enter the specified interfaces. For example, it includes filters for incoming packets on interfaces named Ethernet0/0 on all nodes.",
            "outgoingFilter": "@out(Ethernet0/0) refers to filters that get applied when packets exit the specified interfaces."
        },
        "grammar": {
            "filterSpec": "filterTerm [(&|,|\\) filterTerm]",
            "filterTerm": [
                "filterWithNode",
                "filterWithoutNode",
                "(filterSpec)"
            ],
            "filterWithNode": "nodeTerm[filterWithoutThisNode]",
            "filterWithoutNode": "filterWithoutNodeTerm [(&|,|\\) filterWithoutNodeTerm]",
            "filterWithoutNodeTerm": [
                "<filter-name>",
                "/<filter-name-regex>/",
                "@in(interfaceSpec)",
                "@out(interfaceSpec)",
                "(filterWithoutNode)"
            ]
        }
    },
    "LocationSpec": {
        "description": "A specification for locations of packets, including where they start or terminate within the network. This specification allows defining whether packets are considered at the interface level (InterfaceLocation) or on the link connected to the interface (InterfaceLinkLocation).",
        "examples": {
            "nodeSpecificInterface": "as1border1 specifies the InterfaceLocation for all interfaces on node as1border1.",
            "specificInterface": "as1border1[Ethernet0/0] specifies the InterfaceLocation for Ethernet0/0 on node as1border1.",
            "vrfSpecificInterface": "@vrf(vrf1) specifies the InterfaceLocation for any interface in vrf1 on all nodes.",
            "interfaceLink": "@enter(as1border1[Ethernet0/0]) specifies the InterfaceLinkLocation for packets entering Ethernet0/0 on as1border1."
        },
        "grammar": {
            "locationSpec": "locationTerm [(&|,|\\) locationTerm]",
            "locationTerm": [
                "locationInterface",
                "@enter(locationInterface)",
                "(locationSpec)"
            ],
            "locationInterface": [
                "nodeTerm",
                "interfaceFunc",
                "interfaceWithNode"
            ]
        }
    },
    "EnumSetSpec": {
        "description": "Many types such as applicationSpec or mlagIdSpec are simply sets of values. Such parameters share a common grammar, but with different base values. Please refer to the specific parameter for the base values. IT IS IMPERATIVE THAT YOU ONLY USE ALLOWED VALUES FOR THE SPECIFIC PARAMETER.",
        "examples": [
            "val1 specifies a singleton set with that value.",
            "/val.*/ specifies a set whose values all match regex val.*.",
            "val1, val2 specifies a set with exactly those two values.",
            "! val1 specifies all values other than val1.",
            "/val.*/, ! val1 specifies all values that match regex val.* other than val1."
        ],
        "grammar": {
            "enumSetSpec": "enumSetTerm [, enumSetTerm]",
            "enumSetTerm": [
                "<enum-value>",
                "!<enum-value>",
                "/<regex-over-enum-values>/",
                "!/<regex-over-enum-values>/"
            ]
        }
    },
    "HeaderConstraintsSpec": {
        "description": "Specifies constraints on IPv4 packet headers by defining lists of allowed values for various fields.",
        "examples": {
            "simpleProtocol": "HeaderConstraints(ipProtocols=['TCP', 'UDP']) allows packets that are either TCP or UDP.",
            "complexExample": "HeaderConstraints(srcIps='1.1.1.1', dstIps='2.2.2.2', applications=['SSH']) means an SSH connection originating at 1.1.1.1 and going to 2.2.2.2."
        },
        "fields": {
            "srcIps": "Source IP addresses.",
            "dstIps": "Destination IP addresses.",
            "srcPorts": "Source port ranges, e.g., '22,53-99'.",
            "dstPorts": "Destination port ranges, e.g., '22,53-99'.",
            "ipProtocols": "IP protocols such as TCP, UDP, ICMP.",
            "applications": "Application protocols like SSH, DNS, SNMP.",
            "icmpCodes": "Integer ICMP codes.",
            "icmpTypes": "Integer ICMP types.",
            "dscps": "Allowed DSCP value ranges.",
            "ecns": "Allowed ECN values ranges.",
            "packetLengths": "Allowed packet length value ranges.",
            "fragmentOffsets": "Allowed fragment offset value ranges.",
            "tcpFlags": "Conditions on which TCP flags to match."
        },
        "method": {
            "description": "Create header constraints from an existing flow.",
            "usage": "classmethodof(flow: Flow) -> HeaderWarriorConstraints",
            "example": "Use this method to generate header constraints based on an already defined flow."
        }
    }
}