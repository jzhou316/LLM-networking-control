[
    {
        "text": "Configure connected interfaces between leaf and spine devices in separate class A IP network segments. Configure each leaf connected to the end-hosts appropriately so there is no conflict in IP addressing done for interfaces between leaf and spine devices.",
        "extracted_entities": {
            "operation": [
                "configure"
            ],
            "target": [
                "interfaces"
            ],
            "origin": "leaf",
            "destination": "spine",
            "traffic": "class A IP network segments",
            "group": "end-hosts"
        },
        "nile_statement": "define intent configureIntent: from endpoint('leaf') to endpoint('spine') allow traffic('classAIPNetworkSegments')",
        "grammar_check": true,
        "iterations": 4,
        "time": 20.478865146636963,
        "intent_length": 256,
        "nile_length": 114
    },
    {
        "text": "Connect Ethernet4 of each Leaf to Ethernet4 of each Spine and assign IP addresses to them to bring up connectivity",
        "extracted_entities": {
            "operation": "bring up",
            "origin": "Ethernet4 of each Leaf",
            "destination": "Ethernet4 of each Spine",
            "target": "connectivity"
        },
        "nile_statement": "define intent connectIntent: from endpoint('Ethernet4ofeachLeaf') to endpoint('Ethernet4ofeachSpine') allow service('IPaddresses')",
        "grammar_check": true,
        "iterations": 1,
        "time": 10.66499662399292,
        "intent_length": 114,
        "nile_length": 130
    },
    {
        "text": "Configure iBGP between Leaf and Spine devices. Configure eBGP between each leaf and end-hosts. Ensure end-hosts can ping each other.",
        "extracted_entities": {
            "middlebox": [
                "iBGP",
                "eBGP"
            ],
            "origin": "Leaf",
            "destination": "Spine",
            "target": "end-hosts",
            "operation": [
                "configure",
                "ensure"
            ]
        },
        "nile_statement": "define intent networkIntent: from endpoint('Leaf') to endpoint('Spine') add middlebox('iBGP') from endpoint('Leaf') to endpoint('endhosts') add middlebox('eBGP') allow traffic('ping')",
        "grammar_check": false,
        "iterations": 8,
        "time": 36.96711230278015,
        "intent_length": 132,
        "nile_length": 183
    },
    {
        "text": "Assign different AS numbers on Leaf and Spine layers. Bring up the bgp peering between leaf and spine nodes using the IP addresses configured on the connected interfaces. Advertise the host routes from the locally connected servers within bgp",
        "extracted_entities": {
            "operation": [
                "assign",
                "bring up",
                "advertise"
            ],
            "group": [
                "Leaf",
                "Spine"
            ],
            "protocol": "bgp",
            "traffic": "host routes",
            "origin": "servers",
            "destination": [
                "Leaf",
                "Spine"
            ]
        },
        "nile_statement": "define intent bgpIntent: for group('Leaf'), group('Spine') allow protocol('bgp') start datetime('2023-10-01T00:00:00') end datetime('2023-10-01T23:59:59') define intent hostRoutesIntent: from endpoint('servers') to group('Leaf'), group('Spine') allow traffic('host routes')",
        "grammar_check": false,
        "iterations": 8,
        "time": 42.453054904937744,
        "intent_length": 242,
        "nile_length": 273
    },
    {
        "text": "ensure VXLAN works over the BGP and end-hosts can ping each other.",
        "extracted_entities": {
            "middlebox": [
                "vxlan",
                "bgp"
            ],
            "operation": "ensure",
            "traffic": "ping",
            "target": "end-hosts"
        },
        "nile_statement": "define intent connectivityIntent: for group('end-hosts') allow traffic('ping') add middlebox('vxlan'), add middlebox('bgp')",
        "grammar_check": false,
        "iterations": 8,
        "time": 35.276968479156494,
        "intent_length": 66,
        "nile_length": 123
    },
    {
        "text": "first ensure that the underlay connectivity has been established between leaf and spine routers. Then enable the overlay configuration on each of the leaf router. L2VNI configuration needs to be enabled for Intra vlan traffic and L3VNI configuration is needed for Inter vlan",
        "extracted_entities": {
            "operation": [
                "ensure",
                "enable"
            ],
            "middlebox": [
                "underlay connectivity",
                "overlay configuration"
            ],
            "traffic": [
                "Intra vlan",
                "Inter vlan"
            ],
            "target": [
                "leaf router",
                "spine router"
            ]
        },
        "nile_statement": "define intent networkIntent: for endpoint('leafRouter'), endpoint('spineRouter') add middlebox('underlayConnectivity') add middlebox('overlayConfiguration') for traffic('IntraVlan') add middlebox('L2VNI') for traffic('InterVlan') add middlebox('L3VNI')",
        "grammar_check": false,
        "iterations": 8,
        "time": 39.65556287765503,
        "intent_length": 274,
        "nile_length": 252
    },
    {
        "text": "Configure layer-3 port-channels between interfaces connected between leaf and spine devices. Ensure that any two members of the same physical interface on either leaf or spine are not on the same port-channel.",
        "extracted_entities": {
            "operation": "configure",
            "middlebox": "port-channel",
            "origin": "leaf",
            "destination": "spine"
        },
        "nile_statement": "define intent portChannelConfig: from endpoint('leaf') to endpoint('spine') add middlebox('portChannel')",
        "grammar_check": true,
        "iterations": 1,
        "time": 9.346067190170288,
        "intent_length": 209,
        "nile_length": 104
    },
    {
        "text": "Connect multiple interfaces between leaf and spine routers. Group them together using portchannel configuration",
        "extracted_entities": {
            "operation": "connect",
            "middlebox": "portchannel",
            "origin": "leaf",
            "destination": "spine"
        },
        "nile_statement": "define intent connectIntent: from endpoint('leaf') to endpoint('spine') add middlebox('portchannel')",
        "grammar_check": true,
        "iterations": 0,
        "time": 6.199193716049194,
        "intent_length": 111,
        "nile_length": 100
    },
    {
        "text": "If the IP address learned in the route is for directly connected neighbor then allow IP traffic for that route. Other wise deny.",
        "extracted_entities": {
            "operation": [
                "allow",
                "deny"
            ],
            "traffic": "IP",
            "target": "route"
        },
        "nile_statement": "define intent routeIntent: for endpoint('route') allow traffic('IP') block traffic('IP')",
        "grammar_check": true,
        "iterations": 4,
        "time": 18.909665822982788,
        "intent_length": 128,
        "nile_length": 88
    },
    {
        "text": "Configure acls on each leaf node filtering unwanted traffic. Allow only certain hosts behind leaf0 to talk to hosts behind leaf1. This is done by specifying the allowed source and destination IP addresses within the acl",
        "extracted_entities": {
            "operation": [
                "configure",
                "allow"
            ],
            "middlebox": "acl",
            "traffic": "unwanted",
            "origin": "leaf0",
            "destination": "leaf1"
        },
        "nile_statement": "define intent aclIntent: from endpoint('leaf0') to endpoint('leaf1') add middlebox('acl') allow traffic('unwanted')",
        "grammar_check": true,
        "iterations": 0,
        "time": 6.27937126159668,
        "intent_length": 219,
        "nile_length": 115
    },
    {
        "text": "Classify IP traffic that originates on end-hosts to DCP 2. Ensure that traffic that has DSCP set to 2 is mapped to Traffic class 3. Rest of the traffic should be mapped to 1. On every leaf device, apply to every interface that is connected to the end-hosts.",
        "extracted_entities": {
            "origin": "end-hosts",
            "destination": "DCP 2",
            "traffic": "IP traffic",
            "qos_value": "2",
            "qos_metric": "DSCP",
            "target": "Traffic class 3",
            "operation": "classify"
        },
        "nile_statement": "define intent classifyIntent: from endpoint('end-hosts') to endpoint('DCP2') allow traffic('IPtraffic') block traffic('IPtraffic') allow traffic('DSCP2') block traffic('DSCP2')",
        "grammar_check": false,
        "iterations": 8,
        "time": 36.71010684967041,
        "intent_length": 257,
        "nile_length": 176
    },
    {
        "text": "Configure the buffer pools for ingress and egress traffic profiles. On each leaf enable qos policy by mapping traffic to different classes using the DSCP values. Then map the traffic classes to different queues.",
        "extracted_entities": {
            "middlebox": [
                "qos policy"
            ],
            "traffic": [
                "ingress",
                "egress"
            ],
            "protocol": [
                "DSCP"
            ],
            "operation": [
                "configure",
                "enable",
                "map"
            ]
        },
        "nile_statement": "define intent qosIntent: for traffic('ingress'), traffic('egress') set bandwidth('max', '1000', 'mbps') allow protocol('DSCP')",
        "grammar_check": true,
        "iterations": 1,
        "time": 9.323252201080322,
        "intent_length": 211,
        "nile_length": 126
    },
    {
        "text": "Enable the OSPF router process on each leaf and spine node. Then enable the corresponding ospf configuration on each of the interfaces exchanging ospf data with peers. Configure the networks which needed to be advertised via ospf on each of the nodes",
        "extracted_entities": {
            "operation": [
                "enable",
                "configure"
            ],
            "protocol": "ospf",
            "target": [
                "leaf",
                "spine",
                "interfaces",
                "networks"
            ]
        },
        "nile_statement": "define intent ospfIntent: for group('leaf'), group('spine') allow protocol('ospf') allow protocol('ospf')",
        "grammar_check": true,
        "iterations": 4,
        "time": 21.599469900131226,
        "intent_length": 250,
        "nile_length": 105
    }
]